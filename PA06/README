// ~ Overview ~ //

This assignment will give you more practice with recursion.

Suppose you are responsible for mowing the grass on the paths in a corn maze.
Rather than simply going from the entrance to the exit, you would need to cover
every path in the maze.  This is the inspiration for this assignment.  You will
write a function that takes a maze as input and prints a set of driving
directions for covering every path in the maze.

Several samples are included with the starter code.  However, the directions
printed by your code do not have to match the samples.  The only requirement is
that they cover the entire maze (starting from the entrance) without mowing
through walls or beyond the edge of the maze.  There are no other constraints.

This assignment will require some creative thinking.  It is similar to the
problems that are commonly given in programming interviews.


// ~ Learning Goals ~ //

Recursion


// ~ Submitting Your Assignment ~ //

You must submit one zip file to blackboard containing the following:
(1) answer06.c
(2) git.log

You create the zip file using the following command.
 
 > zip pa06.zip answer06.c git.log


// ~ Specification ~ //

Your task is to implement the following function:

	print_directions(char** maze, int w, int h);

'maze' is an array of strings.  When printed in order, they form a rectangular
maze no more than 99 characters wide and 99 characters high with ' ' denoting a
path and 'X' denoting a wall.  'w' is the width of the maze.  'h' is the height
of the maze.  Your code may modify the maze, if you like.

Your code must print a list of instructions consisting of a compass
direction--"N" (up), "E" (right), "S" (down), or "W" (left)--and a number of
cells (characters) to move in that direction.  The mower starts at the entrance,
the space on the upper edge of the maze.  There will only be one entrance.  The
following statement would print a valid instruction, assuming d is one of the
aforementioned directions and n is a positive integer.

	printf("%c %d\n", direction, n);

It is expected that you will use recursion to solve this problem.

Other than the instructions listed above, there are no constraints on the number
of times a particular path can be traversed, the actions when the mower gets to
an intersection, or anything else.  Your code will be tested by simulating the
instructions it prints on some mazes, and checking to see if all paths in the
maze were traversed without mowing through walls our outside of the maze.

The code used to create the sample mazes is called 'amaze' and is included.  To
create a 20x10-character maze (i.e., 21 characters wide, 11 characters high),
you would run `./amaze 5 10 X`.  More generally, running `./amaze <a> <b> X`
will print a maze that is 2*a+1 characters high and 2*b+1 characters wide.  Your
code will only be tested with mazes that were generated by 'amaze'.


// ~ How to start ~ //

To start, create a blank answer06.c file with the following:

#include "answer06.h"
#include <stdio.h>

void print_directions(char** maze, int w, int h) {
	/* YOUR CODE HERE */
}

Next, think through how you would traverse the maze if you were actually mowing
the paths on a ride-on lawn mower.  Use recursion.

You may want to your algorithm on paper before coding it up.

Tip:  Beware of buffer overflow errors.  It is very easy to create segmentation
faults if your "mower" goes through the walls and outside the maze!


// ~ Rules ~ //

As usual, following are strictly required in order to receive credit:
- ZIP file is created exactly as shown above.
- All tests pass.  There is no partial credit for this assignment.
- git.log contains a valid git log (i.e., not empty)
- Assignment is submitted before the deadline.
- Code compiles on ecegrid without any compiler warnings or errors.
- Code runs with no memory errors (as reported by Valgrind).
- Code terminates (i.e., no infinite loop, etc.).
